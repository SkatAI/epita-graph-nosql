- [Guided practice on Mongodb Atlas](#guided-practice-on-mongodb-atlas)
  - [scope](#scope)
  - [There are many ways to play with MongoB](#there-are-many-ways-to-play-with-mongob)
  - [NoSQL terminology](#nosql-terminology)
  - [Atlas](#atlas)
  - [Querying in mongodb](#querying-in-mongodb)
  - [Moaaar dataaaa!](#moaaar-dataaaa)
  - [Connect via your language](#connect-via-your-language)
    - [In the terminal with `mongosh`](#in-the-terminal-with-mongosh)
    - [Connect In python](#connect-in-python)
    - [Let's explore, filtering](#lets-explore-filtering)
  - [Pipelines and aggregation](#pipelines-and-aggregation)
  - [Aggregation](#aggregation)
- [queries vs pipelines](#queries-vs-pipelines)
    - [When Are They Equivalent?](#when-are-they-equivalent)
  - [distinct](#distinct)
  - [Group and Total](#group-and-total)
    - [let's do it](#lets-do-it)
    - [**Basic Match Queries**](#basic-match-queries)
    - [**Projection of Nested Fields**](#projection-of-nested-fields)
    - [**Sorting**](#sorting)
    - [**Group and Aggregate**](#group-and-aggregate)
    - [**Array Aggregation**](#array-aggregation)
    - [**Bucketization**](#bucketization)
    - [**Filtering Arrays in Nested Fields**](#filtering-arrays-in-nested-fields)
    - [**Add Computed Fields**](#add-computed-fields)
    - [**Nested Logical Conditions**](#nested-logical-conditions)
    - [**Pipeline with $setWindowFields**](#pipeline-with-setwindowfields)
    - [**Existence Check**](#existence-check)
    - [**Type Check**](#type-check)
      - [Lookups](#lookups)
    - [1. **Join Movies with Comments**](#1-join-movies-with-comments)
    - [2. **Join Comments with Users**](#2-join-comments-with-users)
    - [3. **Find Movies with Their Theaters**](#3-find-movies-with-their-theaters)
    - [4. **Find Users Who Commented on a Specific Movie**](#4-find-users-who-commented-on-a-specific-movie)
    - [5. **Join Theaters with Their Locations**](#5-join-theaters-with-their-locations)
    - [6. **Aggregate Ratings for Movies with User Details**](#6-aggregate-ratings-for-movies-with-user-details)
    - [7. **Find Comments for Movies Directed by a Specific Director**](#7-find-comments-for-movies-directed-by-a-specific-director)
    - [Notes](#notes)
    - [**Basic Structure of `$lookup`**](#basic-structure-of-lookup)
    - [**Key Components**](#key-components)
    - [**Example Patterns**](#example-patterns)
      - [**1. One-to-Many Join**](#1-one-to-many-join)
      - [**2. One-to-One Join**](#2-one-to-one-join)
      - [**3. Adding Conditions with `$match` After `$lookup`**](#3-adding-conditions-with-match-after-lookup)
      - [**4. Combine `$lookup` with `$unwind`**](#4-combine-lookup-with-unwind)
      - [**5. Using `$lookup` in Nested Joins**](#5-using-lookup-in-nested-joins)
    - [**Example Use Cases**](#example-use-cases)
      - [**Movies and Comments**](#movies-and-comments)
      - [**Comments and Users**](#comments-and-users)
    - [**Common Patterns for `$lookup`**](#common-patterns-for-lookup)
    - [General Example](#general-example)

# Guided practice on Mongodb Atlas

## scope

- understand diff of cluster location (local, cloud), CLI vs Compass vs CLI in Compass
- [guided] open an account on Atlas
- [guided] demo: how to query a MongoDB database, load a dataset, some queries

## There are many ways to play with MongoB

On your local machine

- MongoDB Community Edition = Self-hosted, runs on your computer
- MongoDB Compass - the GUI tool for visualization
- mongosh the CLI in the terminal

and via your favorite general purpose language : python, node.js, go, ruby, etc ...

In the cloud

- [MongoDB Atlas](https://www.mongodb.com/lp/cloud/atlas/try4-reg) provides Cloud-hosted service with both free and paid tiers.

Today you work on the hosted version Atlas.

This gives us a hosted cluster on which we can create a database, import some collections and understand how to do CRUD operations in MongoDB.

> **CRUD** stands for Create, Read, Update, and Delete : the four basic operations for a DBMS

1. We start with the online ATLAS UI.
2. Then use python, in a local or google colab notebook.

You do not need to install anything.

## NoSQL terminology

In MongoDB:

- A `document` is a record, a row
- A `Collection` is a table
- A `Field` is a Column

| MongoDB | SQL Database |
|----------|--------------|
| Database | Database |
| Collection | Table |
| Document | Record/Row |
| Field | Column |
| Index | Index |
| Embedded Document | Foreign Key |
| `_id` | Primary Key |
| `$lookup` | JOIN |

## Atlas

Let's start by creating an account on Atlas <https://www.mongodb.com/cloud/atlas/register>

Then:

- Create a cluster and a project (I call my project `Sandbox`)

![Create a cluster](./../img/create_new_cluster.png)

Attention: **Copy your database password**. It's best to set it as an environment variable or in a `.env` file (for python).

- Check that your IP is added to the list, visit `Network Access` (left navigation)
  - allow access from any IP using 0.0.0.0/0 (not recommended for production).

![add IP adddress](./../img/atlas_add_ip_address.png)

- Go to clusters
- Create a database: add name `songsdb` and collection name `songs`,
- Insert a Document

```json
{
  "_id":{
    "$oid":"6745ab6f0e0bbdab062667c7"
    },
    "title": "Happy",
    "artist": "Pharrell Williams",
    "year": 2013,
    "mood": "joyful"
}
```

![insert a document](./../img/atlas_insert_document.png)

And insert another one

```json
  "title": "Highway to hell",
  "artist": "AC/DC",
  "year": 1981,
  "mood": "energetic"
```

So we have 2 documents !

Let's explore !!! This is exciting ðŸ¤£ðŸ¤£ðŸ¤£ !

## Querying in mongodb

In MongoDB querying comes down to writing json specifications



| json | query |
|--------|---------|
|`{}` | returns all the documents |
|`{ field : value  }` | where field = value |
|`{ field : { $lt : value }  }` | where field <=> value |

So if we want to find all the documents in our songs collection, simply write '{}' in the query field

This returns our 2 songs.

Similarly if we want to return the songs after a certain year, the query `{ year: { $lt: 2000 } }` returns the song that was released after 2000.

## Moaaar dataaaa!

This is all nice but we need more data to play with.

Let's import the ATLAS sample datasets.

Goto `Clusters > dots > load sample dataset`

![load sample dataset](./../img/atlas_load_sample_dataset.png)


The click on your project name (for me Sandbox ) and `Browse collections` to view the available databases

![Atlas sample databases](./../img/sample_datasetsets_atlas.png)

You get a new database `movies_mflix` with 5 collections.

Look at the `embedded_movies` collection that has 1525 documents and notice the structure of a document (a record)

A document is a JSON record:
It can have nested fields : check out the nested dictionaries `imdb` and the `tomatoes` fields.
and arrays: check out genres, cast, languages, writers, ...

The primary key of a collection is always "_id".

```json
{
    "_id": {
        "$oid": "573a1390f29313caabcd5293"
    },
    "plot": "Young Pauline is left a lot of money when her wealthy uncle dies. However, her uncle's secretary has been named as her guardian until she marries, at which time she will officially take ...",
    "genres": [
        "Action"
    ],
    "runtime": {
        "$numberInt": "199"
    },
    "cast": [
        "Pearl White",
        "Crane Wilbur",
        "Paul Panzer",
        "Edward JosÃ¨"
    ],
    "num_mflix_comments": {
        "$numberInt": "0"
    },
    "poster": "https://m.media-amazon.com/images/M/MV5BMzgxODk1Mzk2Ml5BMl5BanBnXkFtZTgwMDg0NzkwMjE@._V1_SY1000_SX677_AL_.jpg",
    "title": "The Perils of Pauline",
    "fullplot": "Young Pauline is left a lot of money when her wealthy uncle dies. However, her uncle's secretary has been named as her guardian until she marries, at which time she will officially take possession of her inheritance. Meanwhile, her \"guardian\" and his confederates constantly come up with schemes to get rid of Pauline so that he can get his hands on the money himself.",
    "languages": [
        "English"
    ],
    "released": {
        "$date": {
            "$numberLong": "-1760227200000"
        }
    },
    "directors": [
        "Louis J. Gasnier",
        "Donald MacKenzie"
    ],
    "writers": [
        "Charles W. Goddard (screenplay)",
        "Basil Dickey (screenplay)",
        "Charles W. Goddard (novel)",
        "George B. Seitz",
        "Bertram Millhauser"
    ],
    "awards": {
        "wins": {
            "$numberInt": "1"
        },
        "nominations": {
            "$numberInt": "0"
        },
        "text": "1 win."
    },
    "lastupdated": "2015-09-12 00:01:18.647000000",
    "year": {
        "$numberInt": "1914"
    },
    "imdb": {
        "rating": {
            "$numberDouble": "7.6"
        },
        "votes": {
            "$numberInt": "744"
        },
        "id": {
            "$numberInt": "4465"
        }
    },
    "countries": [
        "USA"
    ],
    "type": "movie",
    "tomatoes": {
        "viewer": {
            "rating": {
                "$numberDouble": "2.8"
            },
            "numReviews": {
                "$numberInt": "9"
            }
        },
        "production": "PathÃ¨ FrÃ¨res",
        "lastUpdated": {
            "$date": {
                "$numberLong": "1441993579000"
            }
        }
    }
}
```

We're going to switch to python to explore that movies database and learn how to query in MongoDB.

## Connect via your language

The ATLAS UI is great but I'd rather work with code than a UI.

Atlas allows you to connect to your cluster

![connect to your cluster](./../img/connect_to_cluster.png)

### In the terminal with `mongosh`

Install `mongosh` from https://www.mongodb.com/docs/mongodb-shell/install/ or follow instructions given in Atlas

Then connect with the `mongosh` shell utility (replace with your database cluster URI and username)

```bash
mongosh "mongodb+srv://<cluster_name>.<w932a>.mongodb.net/" --apiVersion 1 --username <username>
```

### Connect In python

We need the [pymongo](https://pypi.org/project/pymongo/) package

```bash
pip install pymongo
```

The connection string is

```python
connection_string = "mongodb+srv://alexis:<db_password>@skatai.w932a.mongodb.net/?retryWrites=true&w=majority&appName=SkatAI"
```

Note: it's best to put the connection string as an environment variable (`$MONGO_ATLAS_URI`), for instance in a `.env` file. then load it with

```python
import os
from dotenv import load_dotenv

load_dotenv()

MONGO_ATLAS_URI = os.getenv('MONGO_ATLAS_URI')
```

And then

```python
from pymongo import MongoClient

def connect_to_atlas(connection_string):
    """
    Connect to a MongoDB Atlas cluster.

    Args:
        connection_string (str): Your MongoDB Atlas connection string.

    Returns:
        MongoClient: The MongoDB client instance.
    """
    try:
        client = MongoClient(connection_string)
        # Test the connection
        client.admin.command('ping')
        print("Connected to MongoDB Atlas successfully!")
        return client
    except Exception as e:
        print(f"An error occurred: {e}")
        return None

# Replace '<your_connection_string>' with your actual connection string
connection_string =  os.getenv('MONGO_ATLAS_URI')
client = connect_to_atlas(connection_string)

```

Once we have a client we can connect to the database and instanciate a collection object

```python
# Example usage: Access a database and collection
if client:
    db = client["sample_mflix"]  # Replace with your database name
    collection = db["movies"]   # Replace with your collection name
```

The collection object is of the class `pymongo.synchronous.collection.Collection` and has many methods:

![many collections methods](./../img/collection_many_methods.png)

For instance, find the 1st document with `find_one()`

```python
print(collection.find_one())  # Fetch one document from the collection
```

### Let's explore, filtering

https://www.mongodb.com/docs/manual/reference/glossary/

A **query predicate** is an expression that returns a boolean indicating whether a document matches the specified query. For example, { name: { $eq: "Alice" } }, which returns documents that have a field "name" whose value is the string "Alice".

An empty query predicate ({ }), the query returns all documents in the collection.

For instance, `find()` with an empty predicate will return all the document in the collection

```python
print(collection.find({}))
```

Main functions on a collections

| function | returns |
|----------|---------|
| .find() | all the documents |
| .find_one() | the 1st document |
| .distinct("<field>") | list of distinct values for the <field> |
| .count_documents({}) | number of documents for the collection or returned by the filter in the query predicate |

Not also

- find_one_and_replace()
- find_one_and_update()
and

- delete_many()
- delete_many()
- drop_index()

You can chain these methods with limit and sort

```python
collection.find(   {'runtime': {'$gt': 120}}   ).limit(3)
```

The returned result is a cursor. a cursor is a tool for iterating over MongoDB query result sets.

## Pipelines and aggregation
Although we can query and modify the data with direct methods applied to the collection, MongoDB has a more powerful features that not only filters, and project but also transforms the data.

An aggregation pipeline is a framework for processing and transforming data through a sequence of stages, where each stage applies specific operations (e.g., filtering, grouping, projecting) to produce a final result.

It takes the form of a list where each element performs a task

A pipeline is execiyted with the  `.aggregate` method

Best to look at an example

```python
db.movies.aggregate([
    // Step 1: Filter movies with an IMDb rating greater than 8.0
    {
        $match: { "imdb.rating": { $gt: 8.0 } }
    },

    // Step 2: Project only the fields we are interested in (title and IMDb rating)
    {
        $project: {
            _id: 0,               // Exclude the default _id field
            title: 1,             // Include the title field
            "imdb.rating": 1      // Include the IMDb rating field
        }
    },

    // Step 3: Sort the results by IMDb rating in descending order
    {
        $sort: { "imdb.rating": -1 }
    }
])

```

With direct methods this pipeline would come down to

```python
db.movies.find(
    { "imdb.rating": { $gt: 8.0 } },  // Filter criteria (equivalent to $match)
    { _id: 0, title: 1, "imdb.rating": 1 }  // Projection (equivalent to $project)
).sort(
    { "imdb.rating": -1 }  // Sorting (equivalent to $sort)
)
```

But there are many things that are possible with a pipeline and not possible with direct methods./

--- see below for exaeple


## Aggregation

https://www.mongodb.com/docs/manual/core/aggregation-pipeline/
https://www.mongodb.com/resources/products/capabilities/aggregation-pipeline

https://learn.mongodb.com/courses/mongodb-aggregation-in-python

An aggregation pipeline consists of one or more stages that process documents:

    Each stage performs an operation on the input documents. For example, a stage can filter documents, group documents, and calculate values.

    The documents that are output from a stage are passed to the next stage.

    An aggregation pipeline can return results for groups of documents. For example, return the total, average, maximum, and minimum values.


see
https://learn.mongodb.com/learn/course/mongodb-crud-operations-in-python/lesson-3-querying-a-mongodb-collection-in-python-applications/learn?client=customer&page=2

for CRUD in python

https://www.mongodb.com/docs/languages/python/pymongo-driver/current/aggregation/aggregation-tutorials/

https://learn.mongodb.com/courses/mongodb-crud-operations-in-python

operators

https://www.mongodb.com/docs/manual/reference/operator/query/gt/

cursors
https://www.mongodb.com/docs/manual/reference/method/js-cursor/

a cursor is a tool for iterating over MongoDB query result sets.

see methods for pymongo
https://pymongo.readthedocs.io/en/stable/api/pymongo/cursor.html

not conusming the cursor with clone()

len(list(cursor.clone()))

# queries vs pipelines
While there is some overlap, aggregation pipelines offer more powerful and flexible data transformation and computation capabilities than the simpler query methods.


No, there is not always a direct equivalence between MongoDB aggregation pipelines and queries using methods like `find`, `sort`, and `limit`. While there is some overlap, aggregation pipelines offer more powerful and flexible data transformation and computation capabilities than the simpler query methods. Here are the key differences and scenarios where direct equivalence might not exist:

1. **Data Transformation**
- Aggregation pipelines can reshape documents, perform calculations, and add new fields using stages like `$project`, `$group`, and `$addFields`.
- `find` queries are limited to filtering documents and optionally projecting fields (including or excluding).

- Aggregation pipeline:

```json
[
  { "$group": { "_id": "$genre", "averageRuntime": { "$avg": "$runtime" } } }
]
```

Groups documents by genre and calculates the average runtime for each genre.

This cannot be directly replicated with `find`.


**Field Manipulation**

- `$unset` in aggregation allows removing fields from documents.
- In `find`, this is achieved with projections, which can't always remove computed fields.


**Complex Computations**

- `$group`, `$bucket`, `$lookup`, `$unwind`, `$merge`, and `$out` are aggregation pipeline stages with no direct `find` equivalents.
- These stages enable complex operations like grouping, joining collections, and exporting results.

Example:

- Aggregation pipeline for joining collections:
```json
[
  { "$lookup": { "from": "authors", "localField": "authorId", "foreignField": "_id", "as": "authorDetails" } }
]
```

This joins two collections, which is impossible with `find`.

**Document Flow**

- Aggregation pipelines process documents through multiple stages, applying transformations at each stage.
- `find` executes a single query with filtering, sorting, and projection.

**Performance**
- Aggregation pipelines can leverage stages like `$merge` or `$out` to save results into a new collection, useful for data processing pipelines.
- `find` does not save results unless explicitly written to an external process.

### When Are They Equivalent?

Aggregation pipelines can replicate simpler queries that involve filtering, sorting, projecting, and limiting results. For example:

```json
[
  { "$match": { "runtime": { "$gt": 120 } } },
  { "$sort": { "released": -1 } },
  { "$limit": 3 },
  { "$project": { "_id": 0, "plot": 0, "fullplot": 0 } }
]
```
Can be translated to:
```python
db.collection.find(
  { runtime: { $gt: 120 } },
  { _id: 0, plot: 0, fullplot: 0 }
).sort({ released: -1 }).limit(3);
```


For simple queries involving filtering, sorting, limiting, and basic projection, there is often a direct equivalence between `find` and aggregation pipelines. However, for more advanced data transformations, multi-stage processing, and inter-collection operations, aggregation pipelines are indispensable.

## distinct
https://chatgpt.com/c/67480ece-a994-800e-a285-2de89629fc7c


distinct_years = db.movies.distinct("year")

or with a pipeline

```python
pipeline = [
    {
        "$group": {
            "_id": "$year"
        }
    },
    {
        "$sort": {"_id": 1}  # Sort by year in ascending order
    }
]
result = db.movies.aggregate(pipeline)

# Print the distinct years
[doc["_id"] for doc in result]
distinct_years = [doc["_id"] for doc in result]
```

In the $group stage:

    The _id field defines the grouping key.
    Any other fields must use an accumulator operator to compute aggregated values from the grouped documents.


## Group and Total

https://www.mongodb.com/docs/languages/python/pymongo-driver/current/aggregation/aggregation-tutorials/group-total/


let's

Define the aggregation pipeline

Calculate average IMDb rating and Count total movies for each year

```python
pipeline = [
    {
        "$group": {
            "_id": "$year",  # Group by the "year" field
            "average_imdb_rating": {"$avg": "$imdb.rating"},  # Calculate average IMDb rating
            "total_movies": {"$sum": 1}  # Count total movies for each year
        }
    },
    {
        "$sort": {"_id": 1}  # Sort by year in ascending order
    }
]
```

Then  Execute the aggregation pipeline

```
result = db.movies.aggregate(pipeline)
for doc in result:
    print(doc)
```

weird values for years

let's find all the weird years
we use regex

cursor = db.movies.find({"year": {"$regex": "Ã¨"}})

but we could also check the data types

pipeline = [
    {"$group": {"_id": {"type": {"$type": "$year"}}, "count": {"$sum": 1}}}
]


in mongdb we can mix data types

But it's possible to enforce a ddata type when declaring the schema

db.createCollection("movies", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["year", "title"],  // Fields that must be present
            properties: {
                year: {
                    bsonType: "int",  // Enforces that `year` must be an integer
                    description: "Must be an integer and is required"
                },
                title: {
                    bsonType: "string",
                    description: "Title of the movie, must be a string"
                },
                imdb: {
                    bsonType: "object",  // Nested object for IMDb data
                    properties: {
                        rating: {
                            bsonType: "double",  // IMDb rating must be a double
                            description: "Must be a double if present"
                        }
                    }
                }
            }
        }
    }
})

Key Points:

    bsonType: Specifies the BSON data type for the field (e.g., int, string, array, object).
    required: Ensures specific fields are mandatory.
    properties: Defines the constraints for each field.
    description: Adds a helpful description for validation errors.

MongoDB supports schema validation starting from version 3.6, which allows you to enforce data types and other constraints on fields within a collection. This is achieved using the $jsonSchema validation feature when creating or updating a collection.


next : https://www.mongodb.com/docs/languages/python/pymongo-driver/current/aggregation/aggregation-tutorials/unpack-arrays/

there are multiple arryas in the movies collection

genres
cast
languages
writers
countries

and 3 embedded documents: awards, imdb & tomatoes

'awards': {'wins': 0, 'nominations': 1, 'text': '1 nomination.'},
'imdb': {'rating': 8.2, 'votes': 6, 'id': 1541777},
'tomatoes': {'viewer': {'rating': 0.5, 'numReviews': 13},

let's see how we can query the array fields

with the $unwind operator


pipeline.append({
    "$unwind": {
        "path": "$genres"
    }
})

to query over an emebedeed document we use the dot syntax: `imdb.rating`, `tomatoes.viewer.numReviews`
MongoDB allows you to reference deeply nested fields directly in queries.

for instance

db.movies.aggregate([
    { "$match": { "imdb.rating": { "$gt": 8.0 } } },
    { "$sort": { "imdb.rating": -1 } }  // Sort by rating in descending order
])

If you want to query movies and return only the imdb field:
db.movies.find({"imdb.rating": 8.2}, {"imdb": 1, "_id": 0})



db.movies.find({"tomatoes.viewer.rating": 0.5})
db.movies.find({"tomatoes.viewer.rating": {"$gt": 4.0}})

and with logical oprators

To find movies where:

    imdb.rating is greater than 8.0, OR
    imdb.votes is less than 10

Use the $or operator:

db.movies.find({
    "$or": [
        {"imdb.rating": {"$gt": 8.0}},
        {"imdb.votes": {"$lt": 10}}
    ]
})

### let's do it

Find movies with imdb.rating greater than 7.0 and sort them by tomatoes.viewer.rating in descending order:

db.movies.aggregate([
    { "$match": { "imdb.rating": { "$gt": 7.0 } } },
    { "$sort": { "tomatoes.viewer.rating": -1 } }
])

Group movies by tomatoes.viewer.rating and count the number of movies for each rating:

db.movies.aggregate([
    { "$group": {
        "_id": "$tomatoes.viewer.rating",
        "movie_count": { "$sum": 1 }
    }},
    { "$sort": { "_id": 1 } }
])

Compute the average imdb.rating for movies with more than 50 tomatoes.viewer.numReviews:

db.movies.aggregate([
    { "$match": { "tomatoes.viewer.numReviews": { "$gt": 50 } } },
    { "$group": {
        "_id": null,
        "average_imdb_rating": { "$avg": "$imdb.rating" }
    }}
])


Find movies where tomatoes.viewer.numReviews exists:

db.movies.aggregate([
    { "$match": { "tomatoes.viewer.numReviews": { "$exists": true } } }
])


amny other examples

Hereâ€™s a list of questions and their corresponding aggregation pipelines that demonstrate querying on nested fields in the `movies` collection using **aggregation pipelines**.

---

### **Basic Match Queries**
1. **Find all movies where `tomatoes.viewer.rating` is greater than `4.5`:**
   ```javascript
   db.movies.aggregate([
       { "$match": { "tomatoes.viewer.rating": { "$gt": 4.5 } } }
   ])
   ```

2. **Find movies where `imdb.rating` is greater than `8.0` and `tomatoes.viewer.rating` is greater than `3.5`:**
   ```javascript
   db.movies.aggregate([
       { "$match": {
           "imdb.rating": { "$gt": 8.0 },
           "tomatoes.viewer.rating": { "$gt": 3.5 }
       }}
   ])
   ```

---

### **Projection of Nested Fields**
3. **Find movies with `tomatoes.viewer.rating` greater than `4.0` and return only `title`, `imdb.rating`, and `tomatoes.viewer`:**
   ```javascript
   db.movies.aggregate([
       { "$match": { "tomatoes.viewer.rating": { "$gt": 4.0 } } },
       { "$project": { "title": 1, "imdb.rating": 1, "tomatoes.viewer": 1, "_id": 0 } }
   ])
   ```

---

### **Sorting**
4. **Find movies with `imdb.rating` greater than `7.0` and sort them by `tomatoes.viewer.rating` in descending order:**
   ```javascript
   db.movies.aggregate([
       { "$match": { "imdb.rating": { "$gt": 7.0 } } },
       { "$sort": { "tomatoes.viewer.rating": -1 } }
   ])
   ```

---

### **Group and Aggregate**
5. **Group movies by `tomatoes.viewer.rating` and count the number of movies for each rating:**
   ```javascript
   db.movies.aggregate([
       { "$group": {
           "_id": "$tomatoes.viewer.rating",
           "movie_count": { "$sum": 1 }
       }},
       { "$sort": { "_id": 1 } }
   ])
   ```

6. **Compute the average `imdb.rating` for movies with more than `50` `tomatoes.viewer.numReviews`:**
   ```javascript
   db.movies.aggregate([
       { "$match": { "tomatoes.viewer.numReviews": { "$gt": 50 } } },
       { "$group": {
           "_id": null,
           "average_imdb_rating": { "$avg": "$imdb.rating" }
       }}
   ])
   ```

---

### **Array Aggregation**
7. **Create an array of all unique `imdb.rating` values for movies with `tomatoes.viewer.rating` greater than `3.0`:**
   ```javascript
   db.movies.aggregate([
       { "$match": { "tomatoes.viewer.rating": { "$gt": 3.0 } } },
       { "$group": {
           "_id": null,
           "unique_imdb_ratings": { "$addToSet": "$imdb.rating" }
       }}
   ])
   ```

---

### **Bucketization**
8. **Bucket movies by `tomatoes.viewer.rating` into ranges and count how many fall into each range:**
   ```javascript
   db.movies.aggregate([
       { "$bucket": {
           "groupBy": "$tomatoes.viewer.rating",
           "boundaries": [0, 2, 4, 6, 8, 10],
           "default": "Other",
           "output": { "movie_count": { "$sum": 1 } }
       }}
   ])
   ```

---

### **Filtering Arrays in Nested Fields**
9. **Find movies where any value in `tomatoes.critic.reviews` matches "Excellent":**
   ```javascript
   db.movies.aggregate([
       { "$match": { "tomatoes.critic.reviews": "Excellent" } }
   ])
   ```

---

### **Add Computed Fields**
10. **Add a computed field that calculates the difference between `imdb.rating` and `tomatoes.viewer.rating`:**
    ```javascript
    db.movies.aggregate([
        { "$project": {
            "title": 1,
            "imdb.rating": 1,
            "tomatoes.viewer.rating": 1,
            "rating_difference": { "$subtract": ["$imdb.rating", "$tomatoes.viewer.rating"] }
        }}
    ])
    ```

---

### **Nested Logical Conditions**
11. **Find movies where `imdb.rating` is greater than `8.0` OR `tomatoes.viewer.rating` is less than `2.0`:**
    ```javascript
    db.movies.aggregate([
        { "$match": {
            "$or": [
                { "imdb.rating": { "$gt": 8.0 } },
                { "tomatoes.viewer.rating": { "$lt": 2.0 } }
            ]
        }}
    ])
    ```

12. **Find movies where `imdb.rating` is between `7.0` and `9.0`, and `tomatoes.viewer.numReviews` is greater than `100`:**
    ```javascript
    db.movies.aggregate([
        { "$match": {
            "imdb.rating": { "$gte": 7.0, "$lte": 9.0 },
            "tomatoes.viewer.numReviews": { "$gt": 100 }
        }}
    ])
    ```

---

### **Pipeline with $setWindowFields**
13. **Calculate a running average of `imdb.rating` for movies sorted by `tomatoes.viewer.numReviews`:**
    ```javascript
    db.movies.aggregate([
        { "$setWindowFields": {
            "sortBy": { "tomatoes.viewer.numReviews": 1 },
            "output": {
                "running_avg_rating": {
                    "$avg": "$imdb.rating",
                    "window": { "documents": ["unbounded", "current"] }
                }
            }
        }}
    ])
    ```

---

### **Existence Check**
14. **Find movies where `tomatoes.viewer.numReviews` exists:**
    ```javascript
    db.movies.aggregate([
        { "$match": { "tomatoes.viewer.numReviews": { "$exists": true } } }
    ])
    ```

15. **Find movies where `imdb.votes` does not exist:**
    ```javascript
    db.movies.aggregate([
        { "$match": { "imdb.votes": { "$exists": false } } }
    ])
    ```

---

### **Type Check**
16. **Find movies where `imdb.rating` is a string (to detect schema inconsistencies):**
    ```javascript
    db.movies.aggregate([
        { "$match": { "imdb.rating": { "$type": "string" } } }
    ])
    ```



#### Lookups


The `$lookup` stage in MongoDB allows you to perform a left outer join between two collections. In the **Atlas sample dataset `sample_mflix`**, you can use `$lookup` to combine data across collections like `movies`, `comments`, `users`, and `theaters`.

Here are a few examples:

---

### 1. **Join Movies with Comments**
Find all comments for each movie.

```javascript
db.movies.aggregate([
    {
        "$lookup": {
            "from": "comments",           // Collection to join
            "localField": "_id",          // Field in the `movies` collection
            "foreignField": "movie_id",   // Field in the `comments` collection
            "as": "movie_comments"        // Output array field
        }
    },
    {
        "$project": { "title": 1, "movie_comments": 1 }  // Project relevant fields
    }
])
```

**Explanation**:
- Joins `movies` with `comments` where the `_id` in `movies` matches `movie_id` in `comments`.
- Creates an array `movie_comments` containing all comments for each movie.

---

### 2. **Join Comments with Users**
Find the user details for each comment.

```javascript
db.comments.aggregate([
    {
        "$lookup": {
            "from": "users",            // Collection to join
            "localField": "email",      // Field in the `comments` collection
            "foreignField": "email",    // Field in the `users` collection
            "as": "user_details"        // Output array field
        }
    },
    {
        "$project": { "text": 1, "user_details": 1 }  // Project relevant fields
    }
])
```

**Explanation**:
- Joins `comments` with `users` where the `email` fields match.
- Returns the comment text and corresponding user details.

---

### 3. **Find Movies with Their Theaters**
For each movie, find theaters showing it (assuming there's a connection based on some shared field, e.g., location or zip code).

```javascript
db.movies.aggregate([
    {
        "$lookup": {
            "from": "theaters",            // Collection to join
            "localField": "theater_ids",   // Field in `movies` (e.g., an array of theater IDs)
            "foreignField": "_id",         // Field in `theaters` collection
            "as": "theater_details"        // Output array field
        }
    },
    {
        "$project": { "title": 1, "theater_details": 1 }
    }
])
```

**Explanation**:
- Joins `movies` with `theaters` using a hypothetical `theater_ids` field in the `movies` collection.

---

### 4. **Find Users Who Commented on a Specific Movie**
List all users who have commented on a particular movie, e.g., "The Godfather".

```javascript
db.comments.aggregate([
    {
        "$match": { "movie_id": ObjectId("573a1390f29313caabcd4323") }  // Match specific movie
    },
    {
        "$lookup": {
            "from": "users",            // Collection to join
            "localField": "email",      // Field in `comments`
            "foreignField": "email",    // Field in `users`
            "as": "user_details"        // Output array field
        }
    },
    {
        "$project": { "text": 1, "user_details": 1 }  // Include relevant fields
    }
])
```

**Explanation**:
- Matches comments for the specified movie.
- Joins with `users` to get the details of the users who commented.

---

### 5. **Join Theaters with Their Locations**
Retrieve detailed location information for each theater.

```javascript
db.theaters.aggregate([
    {
        "$lookup": {
            "from": "locations",        // Hypothetical collection for locations
            "localField": "location.address.zipcode",  // Nested field in `theaters`
            "foreignField": "zipcode",                 // Field in `locations`
            "as": "location_details"                  // Output array field
        }
    },
    {
        "$project": { "theaterId": 1, "location_details": 1 }
    }
])
```

**Explanation**:
- Joins `theaters` with `locations` based on `zipcode`.
- Includes the location details for each theater.

---

### 6. **Aggregate Ratings for Movies with User Details**
Find the average rating for each movie along with user details who rated them.

```javascript
db.comments.aggregate([
    {
        "$group": {                      // Group comments by movie
            "_id": "$movie_id",
            "average_rating": { "$avg": "$rating" },
            "total_reviews": { "$sum": 1 }
        }
    },
    {
        "$lookup": {                     // Join with movies collection
            "from": "movies",
            "localField": "_id",
            "foreignField": "_id",
            "as": "movie_details"
        }
    },
    {
        "$unwind": "$movie_details"      // Unwind to make it a single document per movie
    },
    {
        "$project": {                    // Project relevant fields
            "movie_details.title": 1,
            "average_rating": 1,
            "total_reviews": 1
        }
    }
])
```

**Explanation**:
- Calculates average ratings for each movie.
- Joins with `movies` to get the title of each movie.

---

### 7. **Find Comments for Movies Directed by a Specific Director**
Find all comments on movies directed by "Christopher Nolan."

```javascript
db.movies.aggregate([
    {
        "$match": { "directors": "Christopher Nolan" }  // Match director
    },
    {
        "$lookup": {
            "from": "comments",
            "localField": "_id",
            "foreignField": "movie_id",
            "as": "comments"
        }
    },
    {
        "$project": { "title": 1, "comments": 1 }       // Project relevant fields
    }
])
```

**Explanation**:
- Matches movies directed by Christopher Nolan.
- Joins with `comments` to get all related comments.

---

### Notes
- The `$lookup` stage can join only two collections at a time. For more complex joins, chain multiple `$lookup` stages.
- Ensure indexes exist on `localField` and `foreignField` to optimize performance.
- Use `$unwind` when dealing with nested arrays created by `$lookup`.

Let me know if you'd like to explore more specific examples!


The **general pattern for `$lookup`** in MongoDB is as follows:

---

### **Basic Structure of `$lookup`**
```javascript
{
    $lookup: {
        from: <foreign_collection>,       // The collection to join
        localField: <field_in_current>,   // The field from the current collection
        foreignField: <field_in_foreign>, // The field from the foreign collection
        as: <output_array_field>          // The name of the resulting array field
    }
}
```

### **Key Components**
1. **`from`**: The name of the foreign collection you want to join.
2. **`localField`**: The field in the current collection that serves as the join key.
3. **`foreignField`**: The field in the foreign collection that serves as the join key.
4. **`as`**: The name of the output array where the joined documents will be stored.

---

### **Example Patterns**

#### **1. One-to-Many Join**
If each document in the current collection can have multiple related documents in the foreign collection:
```javascript
{
    $lookup: {
        from: "foreign_collection",
        localField: "_id",
        foreignField: "current_collection_id",
        as: "related_documents"
    }
}
```

- Each document in the current collection will have an array `related_documents` containing all matching documents from the foreign collection.

---

#### **2. One-to-One Join**
If each document in the current collection can match exactly one document in the foreign collection:
```javascript
{
    $lookup: {
        from: "foreign_collection",
        localField: "_id",
        foreignField: "related_id",
        as: "single_document"
    }
}
```

- The resulting array in `as` will usually have one document, but it will still be an array unless further processed with `$unwind`.

---

#### **3. Adding Conditions with `$match` After `$lookup`**
You can filter the results of a `$lookup` using `$match`:
```javascript
[
    {
        $lookup: {
            from: "foreign_collection",
            localField: "field_in_current",
            foreignField: "field_in_foreign",
            as: "joined_data"
        }
    },
    {
        $match: { "joined_data.some_field": { $exists: true } }
    }
]
```

---

#### **4. Combine `$lookup` with `$unwind`**
If you need each joined document as a separate result (not in an array):
```javascript
[
    {
        $lookup: {
            from: "foreign_collection",
            localField: "field_in_current",
            foreignField: "field_in_foreign",
            as: "joined_data"
        }
    },
    {
        $unwind: "$joined_data"  // Flattens the joined array into individual documents
    }
]
```

---

#### **5. Using `$lookup` in Nested Joins**
You can chain `$lookup` stages to join multiple collections:
```javascript
[
    {
        $lookup: {
            from: "second_collection",
            localField: "field_in_first",
            foreignField: "field_in_second",
            as: "first_join"
        }
    },
    {
        $lookup: {
            from: "third_collection",
            localField: "first_join.field_in_second",
            foreignField: "field_in_third",
            as: "second_join"
        }
    }
]
```

---

### **Example Use Cases**

#### **Movies and Comments**
Link movies to their comments:
```javascript
{
    $lookup: {
        from: "comments",
        localField: "_id",
        foreignField: "movie_id",
        as: "comments"
    }
}
```

#### **Comments and Users**
Link comments to the users who made them:
```javascript
{
    $lookup: {
        from: "users",
        localField: "email",
        foreignField: "email",
        as: "user_details"
    }
}
```

---

### **Common Patterns for `$lookup`**

1. **One-to-Many Relationships**:
   - Use `$lookup` to join and add related documents as arrays.
   - Apply `$unwind` if necessary to process individual matches.

2. **Filtering Results After Join**:
   - Use `$match` to refine the results based on the joined data.

3. **Combining with `$project`**:
   - Use `$project` to include only the necessary fields from both collections.

4. **Handling Multiple Levels**:
   - Use nested `$lookup` stages to join across more than two collections.

5. **Optimizing with Indexes**:
   - Ensure `localField` and `foreignField` are indexed to improve performance.

---

### General Example
Suppose you want to join movies with comments and only include movies with more than 5 comments:
```javascript
db.movies.aggregate([
    {
        $lookup: {
            from: "comments",
            localField: "_id",
            foreignField: "movie_id",
            as: "movie_comments"
        }
    },
    {
        $match: { "movie_comments.5": { $exists: true } }  // Movies with at least 6 comments
    },
    {
        $project: { "title": 1, "movie_comments": 1 }  // Include only necessary fields
    }
])
```

This pattern illustrates how `$lookup` is combined with `$match` and `$project` for practical queries.